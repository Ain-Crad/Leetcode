### C++ 程序编译过程

- **预处理**：处理以 # 开头的指令
- **编译、优化**：将.cpp文件翻译成 .s汇编代码
- **汇编**：将汇编代码.s翻译成二进制机器文件.o
- **链接**：链接将多个.o文件连接成一个整体，生成可执行程序.exe文件。

<img src="./imgs/cpp1.png" style="zoom: 67%;" />

#### 静态链接：

如果一个程序使用静态链接，它会从静态链接库中复制所需要的那部分代码，使其成为程序的一部分。

- 对静态库的链接是在**编译时期**完成的
- 由于二进制文件中包含静态库中的代码，所以二进制文件体积会比较大。
- 程序在运行时已经和库之间没有联系，使得程序移植方便
- 静态库更新时，使用它的应用程序需要**重新编译**

#### 动态链接

如果一个程序使用动态编译，它只会引用需要的那部分代码，不会将库中代码和自身整合在一起。

- 动态库是在程序**运行**时被链接的
- 二进制文件中不包含动态库的代码，所以二进制文件的体积比较小
- 动态库更新时，不需要重新编译使用它的应用程序
- 动态库会增加额外的程序运行时间，因为需要在运行时链接库中相关代码

### sizeof 和 strlen 的区别

- ``sizeof``是C++中的运算符，``strlen``是头文件<cstring>中的函数

- ``sizeof``计算的是数据类型占内存的大小；而``strlen``计算的是字符串的长度。
- ``sizeof``的参数可以是类型，也可以是变量；``strlen``的参数必须是``char*``类型的变量。
- ``sizeof``在编译时计算长度，``strlen``在程序运行过程中计算长度。
- 数组作为``sizeof``的参数不退化，传递给``strlen``就退化为指针了

扩展：

运算符虽然本质也是函数，但是不能自定义，只能重载。

### 栈和堆的区别

- 申请方式：栈是系统自动分配，堆是程序员主动申请
- 栈在内存中是连续的一块空间，最大容量是系统设定好的；堆在内存中的空间是不连续的
- 栈中存放的是局部变量，函数参数等；堆中存放的内容由程序员控制

### 内存对齐

#### 概念

**内存存取粒度**：尽管内存是以字节为单位，但是大部分处理器不是按字节来存取内存的，而是一版会以双字节、四字节、8字节等单位来存取内存。

现考虑4字节存取粒度的处理器，该处理器只能从地址为4的倍数的内存开始读取数据。

假如没有内存对齐机制，数据可以任意存放，一个int变量存放在从地址1开始的连续四个字节中。该处理器读取数据时，要先从0地址开始读取第一个4字节块，剔除0地址的字节，然后再从地址4开始读取下一个4字节块，剔除5，6，7地址的字节，最后合并留下的两块数据放入寄存器，这需要做很多额外的工作。

**对齐基数**：每个特定平台上的编译器都有自己的默认对齐基数。

#### 规则

- 结构体变量的首地址能够被其最宽基本类型成员大小和对齐基数中的较小者所整除。
- 结构体每个成员相对于结构体首地址的偏移量都是该成员大小与对齐基数中的较小者的整数倍
- 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍。

### 智能指针

- **shared_ptr**：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。多计数减为0时，会自动释放内存空间，从而避免了内存泄漏。
- **unique_ptr**：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和复制，但可以进行移动构造和移动赋值（std::move()）。
- **weak_ptr**：指向 shared_ptr 所指向的对象，不拥有指向资源的所有权。weak_ptr 还可以用来解决循环引用的问题。

判断应该使用哪种类型的指针：

- 指针是否需要拥有资源的所有权?

如果是，选择unique_ptr 或 shared_ptr；如果不是选择weak_ptr 或 raw_pointer

- 如果指针拥有资源的所有权，那么该指针是否需要独占所有权？

独占则使用unique_ptr，否则使用 shared_ptr

- 如果不拥有资源的所有权，那么指针变量是否需要再适当的时候感知资源的有效性？

需要则使用 weak_ptr，它可以在适当的时候通过weak_ptr::lock() 获得所有权，当拥有所有权后便可以得知资源的有效性；如果不需要则使用裸指针。

 ### C 和 C++ 的区别

面向对象和面向过程：

- 面向过程：分析解决问题所需的步骤，用函数把这些步骤依次实现。
- 面向对象：把构成问题的各个部分抽象化，分解为各个对象，并且描述某个对象在解决整个问题步骤中的行为。

区别：

- 语言自身：C 语言是面向过程的编程，C++是面向对象的编程。
- 应用领域：C 语言主要用于嵌入式领域，对性能要求很高的场景。C++可以用于应用层的开发。

### 重载、重写、隐藏的区别

**重载**：指同一可访问区被声明几个具有不同参数列的同名函数，根据参数列表决定调用哪个函数，重载不关心函数返回类型。

```C++
class A{
public:
	void fun(int tmp);	// 重载
    void fun(int tmp, float tmpf);	// 重载
    int fun(int tmp)	// error，和第一个函数参数重复，重载不关心函数返回类型
}
```

**隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，只要函数同名，不管参数列表是否相同，基类函数都会被隐藏。

```C++
class Base{
public:
    void fun(int tmp, float tmpl);
}

class Derive : public Base{
public:
    void fun(int tmp);	// 隐藏基类中的同名函数
}

int main(){
    Derive d;
    d.fun(1, 0.1); // error，基类中的同名函数被隐藏
    d.Base::fun(1, 0.1); // OK
}
```

**重写**：在派生类中重写基类中的 virtual 函数。函数名、参数列表和返回值类型都必须和基类中被重写的函数一致，函数体自行实现。

### 什么是多态？多态如何实现？

**多态**：多态就是不同派生类针对同一函数进行了不同的实现。基类的指针指向派生类的对象，使得基类指针呈现不同的表现方式。

**实现方法**：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。

**实现过程**：

1. 在类中用 ``virtual``关键字声明的函数叫做虚函数
2. 存在虚函数的类中有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针。
3. 当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针。由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找响应的虚函数。

![](./imgs/cpp2.png)

**虚函数表**:

- 虚函数表存放的内容：类的虚函数的地址
- 虚函数表建立的时间：**编译阶段**，即程序的编译过程中会将虚函数的地址放在虚函数表中
- 指向虚函数表的指针：存放在对象的内存空间中。

### static 的作用

#### 静态局部变量

改变了局部变量的生命周期，使得该变量可以存在于定义后知道程序运行结束的这段时间。

除了有作用域限制，其它行为和全局变量一致。

#### 静态全局变量、静态函数

改变了全局变量和函数的文件作用域，使得全局变量和函数只能在定义它的文件中使用。

#### 静态成员变量和静态成员函数

- 静态成员变量属于类，为类的所有对象共享。**在类内声明，在类外定义和初始化**，不占用类的空间。在类外定义的时候不需要 static 关键字。

- 静态成员函数属于类，为类的所有对象共享，不能访问类的非静态成员 和 外部函数。没有 ``this`` 指针，因此只能访问静态成员变量和静态成员函数。

### const 的作用

#### const 普通变量

表示该变量的值不可改变

#### const 成员变量

const 成员变量只能在类内声明，在构造函数初始化列表中初始化

const 成员变量只在某个对象的生存周期内是常量，对于整个类而言是可变的。因为类可以创建多个对象，不同对象的 const 成员变量的值可以是不同的。

#### const 成员函数

不能修改成员变量的值，除非有 mutable 修饰。

不能调用非常量成员函数，以防止修改成员变量的值。

### inline 函数

- 内联函数不是在调用时发生控制转移关系，而是在**编译阶段**将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现的内联函数的调用表达式用内联函数的函数体替换
- 普通函数是将程序执行转移到被调用函数所在的内存地址，当函数执行完后返回到执行此函数前的位置。转移操作需要保护现场，被调函数执行完后再恢复现场，该过程需要较大的资源开销。

### malloc  和 new 的区别

- malloc 仅仅分配内存，free仅仅回收内存；new 除了分配内存外还调用对象的构造函数，delete 在回收内存前会调用对象的析构函数。
- malloc 返回的是 void 指针，new 返回的是某种数据类型的指针。

### struct 和 union 的区别

- 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效成员，而结构体所有的成员都是有效的。
- 对联合体的不同成员赋值将会覆盖其他成员的值，而对于结构体的不同成员赋值时，互不影响。
- 联合体的大小为其内部所有变量大小的最大值，而结构体的大小为其内部所有变量大小的和（不考虑字节对齐）

### volatile

当对象的值可能在程序的控制或检测之外被改变时，应该将对象声明为 volatile ，告知编译器不应该对这样的对象进行优化。

#### 使用场景

- 当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用 volatile 关键字对该变量进行修饰
- 中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰

### extern C 的作用

当 C++ 程序需要调用 C 语言编写的函数时，C++ 使用链接指示，即``extern “C”``来指出任意非 C++ 函数所用的语言。

```C++
// 可能出现在 C++ 头文件 <cstring> 中的链接指示
extern "C"{
    int strcmp(const char*, const char*);
}
```

原因在于 C++ 和 C 语言编译后函数的签名方式不一样，加上extern后，会指示编译器这部分代码按C语言的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

```C++
void fun(int x, int y);

// C语言中，编译后函数在库中的名字为_fun
// C++中，编译后函数在库中的名字为_fun_int_int
```

### sizeof(1 == 1) 在 C 和 C++中的结果

C：4

C++：1

原因：C语言中没有bool类型，按照int型处理

### memcpy 和 memmove

memcpy 和 memmove都是将一块内存区域的数据拷贝到另一块内存区域上。

但是memcpy 在两块内存区域有重叠的情况下会导致错误的拷贝，而memmove不会。原因在于memcpy总是从前向后拷贝，而memmove会检测重叠情况。

```C++
void* memmove(void* dst, const void* src, size_t n){
    char* psrc;
    char* pdst;
    if(dst == nullptr || src == nullptr) return nullptr;
    
    if((dst > src && (char*)dst < (char*)src + n){	// 地址重叠，自后向前拷贝
        psrc = (char*)src + n - 1;
        pdst = (char*)dst + n - 1;
        while(n--){
            *pdst-- = *psrc--;
        }
    }else{
        psrc = (char*)src;
        pdst = (char*)dst;
        while(n--){
            *pdst++ = *psrc++;
        }
    }
    return dst;
}
```

### 构造函数、析构函数是否需要定义成虚函数

构造函数不能定义成虚函数。构造函数是在实例化对象的时候进行调用，如果将构造函数定义成虚函数，需要通过访问该对象所在内存空间才能进行虚函数的调用，但是此时对象还未创建。

析构函数一般需要定义成虚函数。当基类的指针或引用指向派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中的成员无法释放，导致内存泄漏。

### 为什么拷贝构造函数必须为引用

避免拷贝构造函数无限递归。

### C++ 类对象的初始化顺序

构造函数调用顺序：

- 按照派生类继承基类的顺序，依次调用基类的构造函数
- 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数
- 执行派生类自身的构造函数

析构顺序和构造顺序相反

### 编译时多态和运行时多态

- 编译时多态：在程序编译过程中出现，发生在模板和函数重载中
- 运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。

### 左值和右值

左值：能取地址，具名对象，表达式结束后仍然存在的持久对象

右值：不能取地址，匿名对象，表达式结束后就不再存在的临时对象。（一般在寄存器中临时保存）

### 指针和引用的区别

- 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。
- 指针可以为空，但是引用必须绑定对象
- sizeof：指针的大小是4或者8，引用的大小则是被引用的对象的大小
- 指针本身在内存中占有空间，引用相当于变量的别名，在内存中不占空间。

### 强制类型转换

#### static_cast

- 用于基本类型之间的强制转换
- 用于基类和派生类之间**指针或者引用**的转换，向上转换时安全的，向下转换时不安全的。
- 可以将空指针转换成特定类型的指针

#### const_cast

强制去掉const属性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针

#### reinterpret_cast

- 改变指针的类型
- 将指针转换为一个整型，或将一个整型转换成指针

#### dynamic_cast

- 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。
- 只能用于带有虚函数的类，用于类层次间的向上和向下转换。通过判断在执行到该语句的时候的变量的**运行时类型**和要转换的类型是否相同来判断是否能够进行向下转换。
- 只能转指针或引用。不能用于基本类型转换。



### 判断结构体是否相等

需要重载 ``==``操作符，不能使用函数 ``memcpy``，因为 ``memcpy``时逐个字节进行比较的，而结构体在内存空间中保存时存在字节对齐，字节对齐时补齐的内容是随机的，不能保证相等。

### 函数模板和类模板的区别

- 实例化方式：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式的指定。
- 实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类
- 特例化：函数模板只能全特化，类模板还可以偏特化